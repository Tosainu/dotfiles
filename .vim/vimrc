" skip when vim-tiny or vim-small
if 0 | endif

" basic settings {{{
" encoding
set encoding=utf-8
set fileencodings=ucs-bom,utf-8,iso-2022-jp,euc-jp,cp932,latin1
set fileformats=unix,dos,mac

scriptencoding utf-8

" vimrc augroup
augroup MyVimrc
  autocmd!
augroup END

" create directory if not exists
function! s:mkdir(dir) abort
  if !isdirectory(a:dir)
    call mkdir(a:dir, 'p')
  endif
endfunction

set breakindent
set colorcolumn=100
set cursorline
set list listchars=tab:>-,trail:-,eol:¬,nbsp:%
set ruler
set title
set laststatus=2
set showtabline=2
set scrolloff=5
set background=dark
set fillchars-=vert:\|
set foldlevel=99 foldmethod=syntax nofoldenable
set matchpairs& matchpairs+=<:>
set noerrorbells visualbell t_vb=
set shortmess& shortmess+=I
set equalalways
set lazyredraw
set switchbuf=useopen,usetab,newtab
set showcmd

set backspace=2
set completeopt=menuone,noinsert,noselect
set nrformats=bin,hex

set expandtab smarttab
set smartindent
set shiftwidth=2 softtabstop=2 tabstop=2
set shiftround

set ignorecase smartcase
set incsearch
set hlsearch
set wrapscan

set cedit=<C-c>
set wildmenu wildmode=longest,full
set wildignorecase

set timeout timeoutlen=500
set ttimeout ttimeoutlen=100
set updatetime=500

if has('unnamedplus')
  set clipboard=unnamedplus
elseif has('clipboard')
  set clipboard=unnamed
endif

set history=1000
set viminfo& viminfo+=n~/.vim/viminfo

set nobackup

set swapfile directory&
let s:swapdir = isdirectory($XDG_RUNTIME_DIR) ?
      \ $XDG_RUNTIME_DIR . '/vim/swap' : expand('~/.vim/swap')
let &directory = s:swapdir . ',' . &directory
call s:mkdir(s:swapdir)

if has('persistent_undo')
  set undofile undodir=~/.vim/undo
  call s:mkdir(&undodir)

  autocmd MyVimrc BufNewFile,BufRead /tmp/*,/var/tmp/* setlocal noundofile
endif

" jump to the last known cursor position
autocmd MyVimrc BufReadPost *
      \ if line("'\"") > 1 && line("'\"") <= line("$") && &ft !~# 'commit' |
      \   exe "normal! g`\"" |
      \ endif

" disable automatic comment insertion
autocmd MyVimrc FileType * call timer_start(0, {->
      \   execute('setlocal formatoptions-=r formatoptions-=o')
      \ })

" ibus
if $GTK_IM_MODULE ==# 'ibus' && executable('ibus')
  function! s:switch_ibus_engine(engine) abort
    silent let l:engine = systemlist('ibus engine')[0]
    if l:engine !=# a:engine
      silent execute '!ibus engine ' . a:engine
    endif
  endfunction
  autocmd MyVimrc InsertLeave * call s:switch_ibus_engine('xkb:us::eng')
endif

filetype plugin indent on
" }}}

" keybind {{{
let g:mapleader = ','

" disable arrow keys
noremap <Up>    <Nop>
noremap <Down>  <Nop>
noremap <Left>  <Nop>
noremap <Right> <Nop>
inoremap <Up>    <Nop>
inoremap <Down>  <Nop>
inoremap <Left>  <Nop>
inoremap <Right> <Nop>

" disable EX-mode
nnoremap  Q <Nop>
nnoremap gQ <Nop>

" disable <F1>
noremap <F1> <Nop>
inoremap <F1> <Nop>

" change window size
nnoremap <S-Up>    <C-W>-
nnoremap <S-Down>  <C-W>+
nnoremap <S-Left>  <C-W><
nnoremap <S-Right> <C-W>>

" navigate window
nnoremap <C-h> <C-w>h
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k
nnoremap <C-l> <C-w>l

" emacs-like cursor move in command-line mode
cnoremap <C-a>  <Home>
cnoremap <C-e>  <End>
cnoremap <C-b>  <Left>
cnoremap <C-f>  <Right>
cnoremap <C-p>  <Up>
cnoremap <C-n>  <Down>
if has('unix') && !has('gui_running')
  cmap <Esc>b <M-b>
  cmap <Esc>f <M-f>
endif
cnoremap <M-b> <S-Left>
cnoremap <M-f> <S-Right>

" clear search highlights
nnoremap <silent> <Esc><Esc> :<C-u>nohlsearch<CR>

" tab
nnoremap <silent> <C-n> :<C-u>tabnew<CR>

" sort
vnoremap <silent> <Leader>s :sort<CR>
vnoremap <silent> <Leader>u :sort u<CR>

" select completion result
inoremap <expr> <Tab>   pumvisible() ? "\<C-n>" : "\<Tab>"
inoremap <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"
inoremap <expr> <CR>    pumvisible() ? "\<C-y>" : "\<CR>"

" toggle line number
nnoremap <silent> <Leader>n :<C-u>setlocal number!<CR>
" }}}

" commands {{{
" https://sanctum.geek.nz/arabesque/vim-command-typos/
command! -bang -nargs=? -complete=file E e<bang> <args>
command! -bang -nargs=? -complete=file W w<bang> <args>
command! -bang -nargs=? -complete=file WQ wq<bang> <args>
command! -bang -nargs=? -complete=file Wq wq<bang> <args>
command! -bang Q q<bang>
command! -bang QA qa<bang>
command! -bang Qa qa<bang>
command! -bang WA wa<bang>
command! -bang Wa wa<bang>
command! -bang WQa wqa<bang>
command! -bang Wqa wqa<bang>

" open .vimrc
command! Vimrc if !empty($MYVIMRC) | execute('args ' . $MYVIMRC) | endif
" }}}

" Terminal {{[
set termkey=<C-q>
tnoremap <silent> <C-z> <C-q>:<C-u>hide<CR>

function! s:open_terminal(new, args) abort
  if a:new || empty(term_list()) || !empty(a:args)
    execute 'terminal' '++close' a:args
  else
    execute 'sbuffer' term_list()[0]
  endif
endfunction
command! -bang -complete=shellcmd -nargs=* Term call s:open_terminal(<bang>0, <q-args>)
nnoremap <silent> <Leader>w :<C-u>Term<CR>
nnoremap <silent> <Leader>W :<C-u>Term!<CR>
" }}}

" C++ {{{
autocmd MyVimrc FileType c,cpp call s:on_cpp_files()
function! s:on_cpp_files() abort
  setlocal cindent
  setlocal cinoptions& cinoptions+=g0,m1,j1,(0,ws,Ws,N-s

  " http://rhysd.hatenablog.com/entry/2013/12/10/233201#namespace
  function! s:expand_namespace() abort
    let l:s = getline('.')[0:col('.') - 2]
    if l:s =~# '\<b;$'
      return "\<BS>oost::"
    elseif l:s =~# '\<s;$'
      return "\<BS>td::"
    elseif l:s =~# '\<d;$'
      return "\<BS>etail::"
    else
      return ';'
    endif
  endfunction
  inoremap <buffer><expr> ; <SID>expand_namespace()
endfunction

autocmd MyVimrc BufReadPost /usr/include/c++/* setlocal filetype=cpp
" }}}

" Haskell {{{
let g:hs_highlight_boolean    = 1
let g:hs_highlight_delimiters = 1
let g:hs_highlight_more_types = 1
let g:hs_highlight_types      = 1

if executable('stylish-haskell')
  autocmd MyVimrc FileType haskell setlocal formatprg=stylish-haskell
endif
" }}}

" Markdown {{{
let g:markdown_fenced_languages = [
      \   'c',
      \   'cpp',
      \   'css',
      \   'haskell',
      \   'html',
      \   'python',
      \   'ruby',
      \   'rust',
      \   'scss',
      \   'sh',
      \   'vim',
      \ ]
" }}}

" Vim {{{
autocmd MyVimrc FileType vim call s:on_vim_files()
function! s:on_vim_files() abort
  " search vim help for word under cursor
  setlocal keywordprg=:help

  setlocal foldmethod=marker
endfunction
" }}}

" binary files {{{
autocmd MyVimrc BufReadPost * if &binary | call s:on_binary_files() | endif
function! s:on_binary_files() abort
  silent %!xxd -g 1
  setlocal filetype=xxd

  autocmd MyVimrc BufWritePre  * %!xxd -r
  autocmd MyVimrc BufWritePost * silent %!xxd -g 1
  autocmd MyVimrc BufWritePost * setlocal nomodified
endfunction
" }}}

" quickfix {{{
autocmd MyVimrc FileType qf nnoremap <buffer><silent> q :<C-u>cclose <bar> lclose<CR>
" }}}

" help {{{
autocmd MyVimrc FileType help nnoremap <buffer><silent> q :<C-u>q<CR>
" }}}

" command-line window {{{
autocmd MyVimrc CmdwinEnter * call s:on_command_line_window()
function! s:on_command_line_window() abort
  nnoremap <buffer><silent> q     :<C-u>q<CR>
  nnoremap <buffer><silent> <Esc> :<C-u>q<CR>
endfunction
" }}}

" colorscheme {{{
syntax on

" https://gist.github.com/XVilka/8346728#detection
let s:supports_truecolor =
      \ has('termguicolors') && $COLORTERM =~# '^\(truecolor\|24bit\)$'
if s:supports_truecolor
  if &t_8f ==# '' || &t_8b ==# ''
    let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
    let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
  endif
  set termguicolors
endif

try
  if s:supports_truecolor || has('gui_running')
    let g:colorsbox_italic = 1
    colorscheme colorsbox-stbright
  elseif &t_Co == 256
    colorscheme last256
  endif
catch
  if s:supports_truecolor
    set termguicolors&
  endif
  colorscheme default
endtry
" }}}

" Plugins {{{
" Disable some pre-installed plugins
let g:loaded_getscriptPlugin  = 1
let g:loaded_gzip             = 1
let g:loaded_logiPat          = 1
let g:loaded_netrwPlugin      = 1
let g:loaded_tar              = 1
let g:loaded_tarPlugin        = 1
let g:loaded_vimballPlugin    = 1
let g:loaded_zip              = 1
let g:loaded_zipPlugin        = 1

" minpac {{{
function! s:init_minpac() abort
  silent! packadd minpac
  if !exists('*minpac#init')
    echomsg 'Failed to load minpac'
    return v:false
  endif

  function! s:plugin(plugname, ...) abort
    let l:opt = extend(copy(get(a:000, 0, {})), {
          \   'cond': {-> v:true},
          \ })
    if !l:opt.cond()
      return
    endif
    if type(a:plugname) == v:t_list
      call map(a:plugname, {_, v -> minpac#add(v, l:opt)})
    else
      call minpac#add(a:plugname, l:opt)
    endif
  endfunction

  call minpac#init()
  call s:plugin('k-takata/minpac', {'type': 'opt'})

  call s:plugin('AndrewRadev/switch.vim')
  call s:plugin('airblade/vim-gitgutter')
  call s:plugin('ctrlpvim/ctrlp.vim')
  call s:plugin('itchyny/lightline.vim')
  call s:plugin('itchyny/vim-gitbranch')
  call s:plugin('junegunn/vim-easy-align')
  call s:plugin('justinmk/vim-dirvish')
  call s:plugin('natebosch/vim-lsc')
  call s:plugin('rhysd/clever-f.vim')
  call s:plugin('rhysd/committia.vim')
  call s:plugin('t9md/vim-textmanip')
  call s:plugin('thinca/vim-quickrun', {'type': 'opt'})
  call s:plugin('tomtom/tcomment_vim')

  " operator/textobj
  call s:plugin('kana/vim-operator-replace')
  call s:plugin('kana/vim-operator-user')
  call s:plugin('rhysd/vim-operator-surround')
  call s:plugin('kana/vim-textobj-user')
  call s:plugin('sgur/vim-textobj-parameter')

  " colorscheme
  call s:plugin('Tosainu/last256', {'type': 'opt'})
  call s:plugin('mkarmona/colorsbox', {'type': 'opt'})

  " code completion
  call s:plugin('Valloric/YouCompleteMe', {
        \   'cond': {-> has('python3') && executable('cmake')},
        \   'do':   {-> [
        \     execute('!./install.py --clang-completer --system-boost --system-libclang'),
        \   ]},
        \   'type': 'opt',
        \ })

  " snippets
  call s:plugin(['SirVer/ultisnips', 'honza/vim-snippets'], {
        \   'cond': {-> has('python3')},
        \ })

  " C++
  call s:plugin('rhysd/vim-clang-format', {'cond': {-> executable('clang-format')}})

  " Haskell
  call s:plugin('Twinside/vim-haskellFold')
  call s:plugin('itchyny/vim-haskell-indent')

  " Markdown
  call s:plugin('plasticboy/vim-markdown')
  call s:plugin('euclio/vim-markdown-composer', {
        \   'cond': {-> executable('cargo')},
        \   'do':   {-> [
        \     execute('!cargo build --release --no-default-features --features json-rpc'),
        \   ]},
        \ })

  " Rust
  call s:plugin('cespare/vim-toml')
  call s:plugin('rust-lang/rust.vim')

  call s:plugin('ap/vim-css-color')
  call s:plugin('slim-template/vim-slim')

  return v:true
endfunction

command! PackInit   call s:init_minpac()
command! PackUpdate if s:init_minpac() | call minpac#update() | endif
command! PackClean  if s:init_minpac() | call minpac#clean()  | endif
" }}}

" vim-gitgutter {{{
let g:gitgutter_max_signs     = 1000
let g:gitgutter_sign_added    = '✚'
let g:gitgutter_sign_removed  = '✘'
let g:gitgutter_sign_modified = '➜'
let g:gitgutter_sign_modified_removed = '➜'
" }}}

" ctrlp.vim {{{
let g:ctrlp_switch_buffer   = 'ET'
let g:ctrlp_extensions      = ['line']
let g:ctrlp_prompt_mappings = {
      \   'AcceptSelection("e")': ['<C-t>'],
      \   'AcceptSelection("t")': ['<CR>'],
      \ }

let g:ctrlp_user_command = {}
let g:ctrlp_user_command.types = {
      \   1: ['.git', 'git --git-dir=%s/.git ls-files -co --exclude-standard'],
      \ }

if executable('ag')
  let g:ctrlp_user_command.fallback = 'ag %s --nocolor --nogroup -g ""'
  let g:ctrlp_use_caching = 0
endif

let g:ctrlp_status_func = {
      \   'main': 'CtrlPStatusFunc_1',
      \   'prog': 'CtrlPStatusFunc_2',
      \ }

function! CtrlPStatusFunc_1(focus, byfname, regex, prev, item, next, marked) abort
  let g:lightline.ctrlp_regex = a:regex
  let g:lightline.ctrlp_prev = a:prev
  let g:lightline.ctrlp_item = a:item
  let g:lightline.ctrlp_next = a:next
  return lightline#statusline(0)
endfunction

function! CtrlPStatusFunc_2(str) abort
  return lightline#statusline(0)
endfunction

nnoremap            [ctrlp]   <nop>
nmap     <Leader>c  [ctrlp]
nnoremap <silent>   [ctrlp]b  :<C-u>CtrlPBuffer<CR>
nnoremap <silent>   [ctrlp]f  :<C-u>CtrlP<CR>
nnoremap <silent>   [ctrlp]l  :<C-u>CtrlPLine<CR>
nnoremap <silent>   [ctrlp]r  :<C-u>CtrlPMRU<CR>
" }}}

" lightline.vim {{{
let g:lightline = {
      \   'colorscheme': 'wombat',
      \   'active': {
      \     'left': [
      \       ['mode', 'textmanip'],
      \       ['readonly', 'filename', 'modified'],
      \     ],
      \     'right': [
      \       ['lineinfo'],
      \       ['filetype', 'fileformat'],
      \       ['git-branch', 'gitgutter'],
      \     ]
      \   },
      \   'inactive': {
      \     'left':       [['filename']],
      \     'right':      [['lineinfo'], ['filetype', 'fileformat']],
      \   },
      \   'component': {
      \     'fileformat': '%{&fenc !=# "" ? &fenc : &enc}[%{&ff}]',
      \     'readonly':   '%{&ro ? "\ue0a2" : ""}',
      \   },
      \   'component_function': {
      \     'filename':   'LightlineFilename',
      \     'git-branch': 'LightlineGitBranch',
      \     'gitgutter':  'LightlineGitGutter',
      \     'mode':       'LightlineMode',
      \     'textmanip':  'LightlineTextmanipMode',
      \   },
      \   'separator':    {'left': "\ue0b0", 'right': "\ue0b2"},
      \   'subseparator': {'left': "\ue0b1", 'right': "\ue0b3"},
      \   'tabline':      {'left': [['tabs']], 'right': []},
      \ }

function! LightlineFilename() abort
  let l:fname = expand('%:t')
  return  l:fname ==# 'ControlP' && has_key(g:lightline, 'ctrlp_item') ? g:lightline.ctrlp_item :
        \ l:fname !=# '' ? l:fname : '[No Name]'
endfunction

function! LightlineMode() abort
  let l:fname = expand('%:t')
  return  l:fname ==# 'ControlP' ? 'CtrlP' :
        \ lightline#mode()
endfunction

function! LightlineTextmanipMode() abort
  return  exists('g:textmanip_current_mode') && (mode() =~? 'v' || mode() ==# "\<C-V>") ?
        \ g:textmanip_current_mode ==# 'insert'  ? 'I' :
        \ g:textmanip_current_mode ==# 'replace' ? 'R' : '' : ''
endfunction

function! LightlineGitBranch() abort
  if winwidth(0) >= 90 && exists('*gitbranch#name')
    let l:_ = gitbranch#name()
    return l:_ !=# '' ? "\ue0a0 " . l:_ : ''
  else
    return ''
  endif
endfunction

function! LightlineGitGutter() abort
  if winwidth(0) >= 90 && get(g:, 'gitgutter_enabled')
    let l:hunks   = GitGutterGetHunkSummary()
    let l:symbols = [
          \   [g:gitgutter_sign_added,    l:hunks[0]],
          \   [g:gitgutter_sign_modified, l:hunks[1]],
          \   [g:gitgutter_sign_removed,  l:hunks[2]],
          \ ]
    return join(map(filter(l:symbols, 'v:val[1] > 0'), 'join(v:val)'))
  else
    return ''
  endif
endfunction
" }}}

" vim-easy-align {{{
nmap ga <Plug>(EasyAlign)
xmap ga <Plug>(EasyAlign)
"}}}

" vim-dirvish {{{
nmap <Plug>(dirvish_up_) <Plug>(dirvish_up)
autocmd MyVimrc FileType dirvish nmap <buffer><silent> - <Plug>(dirvish_up)
" }}}

" clever-f.vim {{{
let g:clever_f_across_no_line = 1
let g:clever_f_smart_case     = 1
" }}}

" committia.vim {{{
let g:committia_hooks = {}
function! g:committia_hooks.edit_open(info) abort
  " enable spell checking
  setlocal spell

  " If no commit message, start with insert mode
  if a:info.vcs ==# 'git' && getline(1) ==# ''
    startinsert
  end
endfunction
" }}}

" vim-quickrun {{{
let g:quickrun_no_default_key_mappings = 1

let g:quickrun_config = {}
let g:quickrun_config._ = {
      \   'outputter': 'error',
      \   'outputter/buffer/close_on_empty': 1,
      \   'outputter/buffer/into':    1,
      \   'outputter/buffer/split':   'botright',
      \   'outputter/error/error':    'loclist',
      \   'outputter/error/success':  'buffer',
      \   'outputter/loclist/into':   1,
      \   'runner': 'job',
      \ }

if executable('clang++')
  let g:quickrun_config.cpp = {
        \   'command':    'clang++',
        \   'cmdopt':     '-Wall -Wextra -std=c++14 -lboost_system -pthread',
        \ }
endif

if executable('stack')
  let g:quickrun_config.haskell = {
        \   'command': 'stack',
        \   'exec': '%c %o %s %a',
        \   'cmdopt': 'runghc',
        \ }
endif

nnoremap <silent>       <Leader>r :<C-u>packadd vim-quickrun <bar> QuickRun<CR>
nnoremap <expr><silent> <C-c>
      \ exists('*quickrun#is_running') && quickrun#is_running() ?
      \ quickrun#sweep_sessions() : "\<C-c>"
" }}}

" tcomment_vim {{{
let g:tcommentMapLeader1= ''
let g:tcommentMapLeader2= ''
" }}}

" switch.vim {{{
nnoremap <silent> <Leader>sw :<C-u>Switch<CR>
" }}}

" vim-textmanip {{{
xmap <Leader>d <Plug>(textmanip-duplicate-down)
xmap <Leader>D <Plug>(textmanip-duplicate-up)
xmap <C-j>     <Plug>(textmanip-move-down)
xmap <C-k>     <Plug>(textmanip-move-up)
xmap <C-h>     <Plug>(textmanip-move-left)
xmap <C-l>     <Plug>(textmanip-move-right)

nmap <silent> <F10> <Plug>(textmanip-toggle-mode)
xmap <silent> <F10> <Plug>(textmanip-toggle-mode)
" }}}

" YouCompleteMe {{{
let g:ycm_complete_in_comments         = 1
let g:ycm_enable_diagnostic_signs      = 0
let g:ycm_extra_conf_vim_data          = ['&filetype']
let g:ycm_global_ycm_extra_conf        = '~/.vim/ycm_extra_conf.py'
let g:ycm_goto_buffer_command          = 'new-or-existing-tab'
let g:ycm_key_list_previous_completion = []
let g:ycm_key_list_select_completion   = []
let g:ycm_python_binary_path           = 'python'

autocmd MyVimrc FileType c,cpp call s:load_ycm()
function! s:load_ycm() abort
  silent! packadd YouCompleteMe
  nnoremap <buffer><silent> <Leader>f  :<C-u>YcmCompleter FixIt<CR>
  nnoremap <buffer><silent> <Leader>gD :<C-u>YcmCompleter GoToDefinition<CR>
  nnoremap <buffer><silent> <Leader>gd :<C-u>YcmCompleter GoToDeclaration<CR>
  nnoremap <buffer><silent> <Leader>t  :<C-u>YcmCompleter GetType<CR>
endfunction
" }}}

" vim-lsc {{{
let g:lsc_enable_incremental_sync = v:true
let g:lsc_server_commands = {
      \   'haskell': 'hie --lsp',
      \   'rust':    'rustup run nightly rls',
      \ }

autocmd MyVimrc FileType haskell,rust call s:set_lsc_keybinds()
function! s:set_lsc_keybinds()
  nnoremap <buffer><silent> <Leader>gd :<C-u>LSClientGoToDefinition<CR>
  nnoremap <buffer><silent> <Leader>t  :<C-u>LSClientShowHover<CR>
endfunction
" }}}

" UltiSnips {{{
let g:UltiSnipsExpandTrigger        = '<C-e>'
let g:UltiSnipsJumpBackwardTrigger  = '<C-b>'
let g:UltiSnipsJumpForwardTrigger   = '<C-e>'
" }}}

" vim-operator-replace {{{
map <Leader>p  <Plug>(operator-replace)
" }}}

" vim-operator-surround {{{
map <Leader>sa <Plug>(operator-surround-append)
map <Leader>sd <Plug>(operator-surround-delete)
map <Leader>sr <Plug>(operator-surround-replace)
" }}}

" vim-clang-format {{{
let g:clang_format#auto_formatexpr = 1
let g:clang_format#style_options = {
      \   'AccessModifierOffset':             -2,
      \   'AlignConsecutiveAssignments':      'true',
      \   'AllowShortFunctionsOnASingleLine': 'Empty',
      \   'ColumnLimit':                      96,
      \   'Cpp11BracedListStyle':             'true',
      \   'DerivePointerAlignment':           'false',
      \   'SortIncludes':                     'false',
      \   'SpacesBeforeTrailingComments':     1,
      \   'Standard':                         'Cpp11',
      \ }
" }}}

" plasticboy/vim-markdown {{{
let g:vim_markdown_conceal                 = 0
let g:vim_markdown_folding_disabled        = 0
let g:vim_markdown_frontmatter             = 1
let g:vim_markdown_new_list_item_indent    = 0
let g:vim_markdown_no_default_key_mappings = 1
" }}}
" }}}
