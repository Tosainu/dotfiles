" skip when vim-tiny or vim-small
if 0 | endif

" basic settings {{{
" encoding
set encoding=utf-8
set fileencodings=ucs-bom,utf-8,iso-2022-jp,euc-jp,cp932,latin1
set fileformats=unix,dos,mac

scriptencoding utf-8

" vimrc augroup
augroup MyVimrc
  autocmd!
augroup END

function! s:get_SID() abort
  return matchstr(expand('<sfile>'), '<SNR>\d\+_\zeget_SID$')
endfunction
let s:SID = s:get_SID()
delfunction s:get_SID

set breakindent
let &showbreak = '» '
set colorcolumn=100
set cursorline
set list listchars=tab:>-,trail:-,eol:¬,nbsp:%
set ruler
set title
set laststatus=2
set showtabline=2
set scrolloff=5
set background=dark
set fillchars-=vert:\|
set foldlevel=99 foldmethod=syntax nofoldenable
set hidden
set matchpairs& matchpairs+=<:>
set noerrorbells visualbell t_vb=
set shortmess& shortmess+=I
set equalalways
set lazyredraw
set switchbuf=useopen,usetab,newtab
set showcmd

set backspace=2
set completeopt=menuone,noinsert,noselect
set nrformats=bin,hex

set expandtab smarttab
set smartindent
set shiftwidth=2 softtabstop=2 tabstop=2
set shiftround

set ignorecase smartcase
set incsearch
set hlsearch
set wrapscan

set cedit=<C-c>
set wildmenu wildmode=longest,full
set wildignorecase

set timeout timeoutlen=500
set ttimeout ttimeoutlen=100
set updatetime=500

if has('unnamedplus')
  set clipboard=unnamedplus
elseif has('clipboard')
  set clipboard=unnamed
endif

set history=1000
set viminfo& viminfo+=n~/.vim/viminfo

set nobackup

set swapfile directory&
let s:swapdir = isdirectory($XDG_RUNTIME_DIR) ?
      \ $XDG_RUNTIME_DIR . '/vim/swap' : expand('~/.vim/swap')
let &directory = s:swapdir . ',' . &directory
call mkdir(s:swapdir, 'p')

if has('persistent_undo')
  set undofile undodir=~/.vim/undo
  call mkdir(&undodir, 'p')

  autocmd MyVimrc BufNewFile,BufRead /tmp/*,/var/tmp/* setlocal noundofile
endif

" jump to the last known cursor position
autocmd MyVimrc BufReadPost *
      \ if line("'\"") > 1 && line("'\"") <= line("$") && &ft !~# 'commit' |
      \   exe "normal! g`\"" |
      \ endif

" disable automatic comment insertion
autocmd MyVimrc FileType * call timer_start(0, {->
      \   execute('setlocal formatoptions-=r formatoptions-=o')
      \ })

" add execute permission to script file
autocmd MyVimrc BufWritePost * call s:make_script_executable()
function! s:make_script_executable() abort
  let b:make_script_executable_checked = get(b:, 'make_script_executable_checked', {})
  let l:file = expand('<afile>:p')
  if !get(b:make_script_executable_checked, l:file, 0)
        \ && getline(1) =~# '^#![^[]'
        \ && !executable(l:file)
        \ && (input(printf('chmod +x %s?[y/n]', l:file)) ==? 'y')
    silent! execute '!chmod +x ' . shellescape(l:file)
    edit
  endif
  let b:make_script_executable_checked[l:file] = 1
endfunction

" cursor shape
if has('cursorshape') && has('vim_starting') && &term =~# 'xterm'
  let &t_EI .= "\e[\x30 q"
  let &t_SI .= "\e[\x35 q"
  let &t_SR .= "\e[\x33 q"
endif

" ibus
if $GTK_IM_MODULE ==# 'ibus' && executable('ibus')
  function! s:switch_ibus_engine(engine) abort
    silent let l:engine = systemlist('ibus engine')[0]
    if l:engine !=# a:engine
      silent execute '!ibus engine ' . a:engine
    endif
  endfunction
  autocmd MyVimrc InsertLeave * call s:switch_ibus_engine('xkb:us::eng')
endif

filetype plugin indent on
" }}}

" keymappings {{{
let g:mapleader = ','

" disable arrow keys
noremap <Up>    <Nop>
noremap <Down>  <Nop>
noremap <Left>  <Nop>
noremap <Right> <Nop>
inoremap <Up>    <Nop>
inoremap <Down>  <Nop>
inoremap <Left>  <Nop>
inoremap <Right> <Nop>

" disable EX-mode
nnoremap  Q <Nop>
nnoremap gQ <Nop>

" disable <F1>
noremap <F1> <Nop>
inoremap <F1> <Nop>

" change window size
nnoremap <S-Up>    <C-W>-
nnoremap <S-Down>  <C-W>+
nnoremap <S-Left>  <C-W><
nnoremap <S-Right> <C-W>>

" navigate window
nnoremap <C-h> <C-w>h
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k
nnoremap <C-l> <C-w>l

" emacs-like cursor move in command-line mode
cnoremap <C-a>  <Home>
cnoremap <C-e>  <End>
cnoremap <C-b>  <Left>
cnoremap <C-f>  <Right>
cnoremap <C-p>  <Up>
cnoremap <C-n>  <Down>
if has('unix') && !has('gui_running')
  cmap <Esc>b <M-b>
  cmap <Esc>f <M-f>
endif
cnoremap <M-b> <S-Left>
cnoremap <M-f> <S-Right>

nnoremap n nzvzz
nnoremap N Nzvzz
nnoremap * *zvzz
nnoremap # *zvzz

" search in new window
nnoremap <expr> <C-w>* "\<C-w>" . (winwidth(0) > 160 ? "v" : "s") . "*"
nnoremap <expr> <C-w># "\<C-w>" . (winwidth(0) > 160 ? "v" : "s") . "#"

" clear search highlights
nnoremap <silent> <Esc><Esc> :<C-u>nohlsearch<CR>

" tab
nnoremap <silent> <C-n> :<C-u>tabnew<CR>

" select completion result
inoremap <expr> <Tab>   pumvisible() ? "\<C-n>" : "\<Tab>"
inoremap <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"

" toggle line number
nnoremap <silent> <Leader>n :<C-u>setlocal number!<CR>
" }}}

" commands {{{
" https://sanctum.geek.nz/arabesque/vim-command-typos/
command! -bang -nargs=? -complete=file E e<bang> <args>
command! -bang -nargs=? -complete=file W w<bang> <args>
command! -bang -nargs=? -complete=file WQ wq<bang> <args>
command! -bang -nargs=? -complete=file Wq wq<bang> <args>
command! -bang Q q<bang>
command! -bang QA qa<bang>
command! -bang Qa qa<bang>
command! -bang WA wa<bang>
command! -bang Wa wa<bang>
command! -bang WQa wqa<bang>
command! -bang Wqa wqa<bang>

" open .vimrc
command! Vimrc execute 'tabedit' resolve($MYVIMRC)
" }}}

" Terminal {{{
set termwinkey=<C-q>
tnoremap <silent> <C-z>      <C-q>:<C-u>hide<CR>
tnoremap <silent> <C-q><C-n> <C-q>N

function! s:open_terminal(new, args) abort
  if (&termguicolors || has('gui_running')) && !exists('g:terminal_ansi_colors')
    let g:terminal_ansi_colors = [
          \   '#191919', '#e63250',
          \   '#a5d862', '#e5ae49',
          \   '#66a6cc', '#a370cc',
          \   '#7accc2', '#d9d9d9',
          \   '#191919', '#ff3759',
          \   '#b9f26e', '#ffc251',
          \   '#73bbe5', '#b77ee5',
          \   '#89e5da', '#f1f1f1',
          \ ]
  endif

  let l:split = winwidth(0) > 160 ? 'vertical' : 'aboveleft'
  if a:new || empty(term_list()) || !empty(a:args)
    execute l:split 'terminal' '++close' a:args
  else
    execute l:split 'sbuffer'
          \ get(filter(term_list(), {_, nr -> bufwinnr(nr) == -1}), 0, term_list()[0])
  endif
endfunction
command! -bang -complete=shellcmd -nargs=* Term call s:open_terminal(<bang>0, <q-args>)
nnoremap <silent> <Leader>w :<C-u>Term<CR>
nnoremap <silent> <Leader>W :<C-u>Term!<CR>
tnoremap <silent> <C-q><Leader>w <C-q>:<C-u>Term<CR>
tnoremap <silent> <C-q><Leader>W <C-q>:<C-u>Term!<CR>
" }}}

" Filetype {{{
" C++ {{{
autocmd MyVimrc FileType c,cpp call s:on_cpp_files()
function! s:on_cpp_files() abort
  setlocal cindent
  setlocal cinoptions& cinoptions+=g0,m1,j1,(0,ws,Ws,N-s

  " http://rhysd.hatenablog.com/entry/2013/12/10/233201#namespace
  function! s:expand_namespace() abort
    let l:s = getline('.')[0:col('.') - 2]
    if l:s =~# '\<b;$'
      return "\<BS>oost::"
    elseif l:s =~# '\<s;$'
      return "\<BS>td::"
    elseif l:s =~# '\<d;$'
      return "\<BS>etail::"
    else
      return ';'
    endif
  endfunction
  inoremap <buffer><expr> ; <SID>expand_namespace()
endfunction

autocmd MyVimrc BufReadPost /usr/include/c++/* setlocal filetype=cpp
" }}}

" Haskell {{{
let g:hs_highlight_boolean    = 1
let g:hs_highlight_delimiters = 1
let g:hs_highlight_more_types = 1
let g:hs_highlight_types      = 1

if executable('stylish-haskell')
  autocmd MyVimrc FileType haskell setlocal formatprg=stylish-haskell
endif
" }}}

" Markdown {{{
let g:markdown_fenced_languages = [
      \   'c',
      \   'cpp',
      \   'css',
      \   'haskell',
      \   'html',
      \   'python',
      \   'ruby',
      \   'rust',
      \   'scss',
      \   'sh',
      \   'vim',
      \ ]
autocmd MyVimrc FileType markdown setlocal tabstop=4 shiftwidth=4 softtabstop=4
" }}}

" Vim {{{
autocmd MyVimrc FileType vim call s:on_vim_files()
function! s:on_vim_files() abort
  " search vim help for word under cursor
  setlocal keywordprg=:help

  setlocal foldmethod=marker
endfunction
" }}}

" binary files {{{
autocmd MyVimrc BufReadPost * if &binary | call s:on_binary_files() | endif
function! s:on_binary_files() abort
  silent %!xxd -g 1
  setlocal filetype=xxd

  autocmd MyVimrc BufWritePre  <buffer> %!xxd -r
  autocmd MyVimrc BufWritePost <buffer> silent %!xxd -g 1
  autocmd MyVimrc BufWritePost <buffer> setlocal nomodified
endfunction
" }}}

" quickfix {{{
autocmd MyVimrc FileType qf nnoremap <buffer><silent> q :<C-u>cclose <bar> lclose<CR>
" }}}

" help {{{
autocmd MyVimrc FileType help nnoremap <buffer><silent> q :<C-u>q<CR>
" }}}

" command-line window {{{
autocmd MyVimrc CmdwinEnter * call s:on_command_line_window()
function! s:on_command_line_window() abort
  nnoremap <buffer><silent> q     :<C-u>q<CR>
  nnoremap <buffer><silent> <Esc> :<C-u>q<CR>
endfunction
" }}}
" }}}

" colorscheme {{{
syntax on

" https://gist.github.com/XVilka/8346728#detection
let s:supports_truecolor =
      \ has('termguicolors') && $COLORTERM =~# '^\(truecolor\|24bit\)$'
if s:supports_truecolor
  if &t_8f ==# '' || &t_8b ==# ''
    let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
    let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
  endif
  set termguicolors
endif

let g:colorsbox_italic = 1

function! s:reset_colorscheme() abort
  let l:colorschemes = {
        \   'dark':  ['colorsbox-stbright', 'last256', 'slate'],
        \   'light': ['github', 'github', 'morning'],
        \ }
  let l:background = &background
  let l:index = s:supports_truecolor || has('gui_running') ? 0 : &t_Co == 256 ? 1 : 2
  try
    execute 'colorscheme' l:colorschemes[l:background][l:index]
  catch
    if s:supports_truecolor
      set termguicolors&
    endif
    execute 'colorscheme' l:colorschemes[l:background][2]
  endtry
endfunction

silent! call s:reset_colorscheme()

function! s:toggle_background_color() abort
  let &background = (&background ==# 'dark' ? 'light' : 'dark')
  call s:reset_colorscheme()
endfunction
command! ToggleBackgroundColor call s:toggle_background_color()
nnoremap <silent> <Leader>bg :<C-u>ToggleBackgroundColor<CR>

autocmd MyVimrc ColorScheme,VimEnter * call s:clear_background_color()
function! s:clear_background_color()
  if !has('gui_running') && &background ==# 'dark'
    highlight Normal ctermbg=NONE guibg=NONE
  endif
endfunction
" }}}

" Plugins {{{
" Disable some pre-installed plugins
let g:loaded_getscriptPlugin  = 1
let g:loaded_gzip             = 1
let g:loaded_logiPat          = 1
let g:loaded_netrwPlugin      = 1
let g:loaded_tar              = 1
let g:loaded_tarPlugin        = 1
let g:loaded_vimballPlugin    = 1
let g:loaded_zip              = 1
let g:loaded_zipPlugin        = 1

" minpac {{{
function! s:init_minpac() abort
  silent! packadd minpac
  if !exists('*minpac#init')
    echomsg 'Failed to load minpac'
    return v:false
  endif

  function! s:plugin(plugname, ...) abort
    let l:opt = extend(copy(get(a:000, 0, {})), {'cond': {-> v:true}}, 'keep')
    if !l:opt.cond()
      return
    endif
    if type(a:plugname) == v:t_list
      call map(a:plugname, {_, v -> minpac#add(v, l:opt)})
    else
      call minpac#add(a:plugname, l:opt)
    endif
  endfunction

  call minpac#init()
  call s:plugin('k-takata/minpac', {'type': 'opt'})

  call s:plugin('AndrewRadev/switch.vim')
  call s:plugin('Yggdroot/indentLine')
  call s:plugin('airblade/vim-gitgutter')
  call s:plugin('ctrlpvim/ctrlp.vim')
  call s:plugin('itchyny/lightline.vim')
  call s:plugin('itchyny/vim-gitbranch')
  call s:plugin('junegunn/vim-easy-align')
  call s:plugin('justinmk/vim-dirvish')
  call s:plugin('rhysd/clever-f.vim')
  call s:plugin('rhysd/committia.vim')
  call s:plugin('rhysd/reply.vim')
  call s:plugin('t9md/vim-textmanip')
  call s:plugin('tyru/caw.vim')
  call s:plugin('w0rp/ale')
  call s:plugin('autozimu/LanguageClient-neovim', {
        \   'branch': 'next',
        \   'cond':   {-> executable('cargo')},
        \   'do':     '!make release',
        \ })

  " operator/textobj
  call s:plugin(['kana/vim-operator-user',
        \   'kana/vim-operator-replace',
        \   'rhysd/vim-operator-surround',
        \ ])
  call s:plugin(['kana/vim-textobj-user',
        \   'kana/vim-textobj-entire',
        \   'kana/vim-textobj-line',
        \   'pocke/vim-textobj-markdown',
        \   'sgur/vim-textobj-parameter',
        \ ])

  " colorscheme
  call s:plugin('Tosainu/last256', {'type': 'opt'})
  call s:plugin('cormacrelf/vim-colors-github', {'type': 'opt'})
  call s:plugin('mkarmona/colorsbox', {'type': 'opt'})

  " code completion
  call s:plugin('Valloric/YouCompleteMe', {
        \   'cond': {-> has('python3') && executable('cmake')},
        \   'do':   '!./install.py --clang-completer --system-boost --system-libclang',
        \   'type': 'opt',
        \ })
  call s:plugin('rhysd/github-complete.vim')

  " snippets
  call s:plugin(['SirVer/ultisnips', 'honza/vim-snippets'], {
        \   'cond': {-> has('python3')},
        \ })

  " C++
  call s:plugin('rhysd/vim-clang-format', {'cond': {-> executable('clang-format')}})

  " Haskell
  call s:plugin('Twinside/vim-haskellFold')
  call s:plugin('itchyny/vim-haskell-indent')

  " Markdown
  call s:plugin('plasticboy/vim-markdown')
  call s:plugin('euclio/vim-markdown-composer', {
        \   'cond': {-> executable('cargo')},
        \   'do':   '!cargo build --release --no-default-features --features json-rpc',
        \ })

  " Rust
  call s:plugin('cespare/vim-toml')
  call s:plugin('rust-lang/rust.vim')

  call s:plugin('ap/vim-css-color')

  return v:true
endfunction

command! PackInit   call s:init_minpac()
command! PackUpdate if s:init_minpac() | call minpac#update('', {'do': 'redraw!'}) | endif
command! PackClean  if s:init_minpac() | call minpac#clean()  | endif
" }}}

" vim-gitgutter {{{
let g:gitgutter_max_signs     = 1000
let g:gitgutter_sign_added    = '✚'
let g:gitgutter_sign_modified = '➤'
let g:gitgutter_sign_removed  = '✖'
let g:gitgutter_sign_modified_removed   = g:gitgutter_sign_modified
let g:gitgutter_sign_removed_first_line = g:gitgutter_sign_removed

nmap <Leader>ha <Plug>GitGutterStageHunk
nmap <Leader>hd <Plug>GitGutterUndoHunk
nmap [c <Plug>GitGutterPrevHunkzvzz
nmap ]c <Plug>GitGutterNextHunkzvzz

omap ih <Plug>GitGutterTextObjectInnerPending
omap ah <Plug>GitGutterTextObjectOuterPending
xmap ih <Plug>GitGutterTextObjectInnerVisual
xmap ah <Plug>GitGutterTextObjectOuterVisual
" }}}

" ctrlp.vim {{{
let g:ctrlp_extensions      = ['line']
let g:ctrlp_open_new_file   = 't'
let g:ctrlp_switch_buffer   = 'ET'

let g:ctrlp_user_command = {}
let g:ctrlp_user_command.types = {
      \   1: ['.git', 'git --git-dir=%s/.git ls-files -co --exclude-standard'],
      \ }

if executable('ag')
  let g:ctrlp_user_command.fallback = 'ag %s --nocolor --nogroup -g ""'
  let g:ctrlp_use_caching = 0
endif

let g:ctrlp_status_func = {
      \   'main': s:SID . 'ctrlp_status_func_main',
      \   'prog': s:SID . 'ctrlp_status_func_prog',
      \ }

function! s:ctrlp_status_func_main(focus, byfname, regex, prev, item, next, marked) abort
  if !exists('*lightline#statusline')
    return &statusline
  endif
  let g:lightline.ctrlp_regex = a:regex
  let g:lightline.ctrlp_prev = a:prev
  let g:lightline.ctrlp_item = a:item
  let g:lightline.ctrlp_next = a:next
  return lightline#statusline(0)
endfunction

function! s:ctrlp_status_func_prog(str) abort
  if !exists('*lightline#statusline')
    return &statusline
  endif
  return lightline#statusline(0)
endfunction

nnoremap            [ctrlp]   <nop>
nmap     <Leader><Leader> [ctrlp]
nnoremap <silent>   [ctrlp]b  :<C-u>CtrlPBuffer<CR>
nnoremap <silent>   [ctrlp]f  :<C-u>CtrlP<CR>
nnoremap <silent>   [ctrlp]l  :<C-u>CtrlPLine<CR>
nnoremap <silent>   [ctrlp]r  :<C-u>CtrlPMRU<CR>
" }}}

" lightline.vim {{{
let g:lightline = {
      \   'colorscheme': 'deus',
      \   'active': {
      \     'left':   [['mode'], ['filename', 'readonly', 'modified']],
      \     'right':  [
      \       ['lineinfo'],
      \       ['filetype', 'fileformat'],
      \       ['branch_name', 'hunk_summary', 'ale_status']
      \     ],
      \   },
      \   'inactive': {
      \     'left':   [['filename', 'readonly', 'modified']],
      \     'right':  [[], ['filetype', 'fileformat']],
      \   },
      \   'tabline': {
      \     'left':   [['tabs']],
      \     'right':  [['cwd']],
      \   },
      \   'component': {
      \     'cwd':        '%{&columns > 160 ? fnamemodify(getcwd(), ":~") : ""}',
      \     'fileformat': '%{&fenc !=# "" ? &fenc : &enc}[%{&ff}]',
      \     'readonly':   '%{&ro ? "\ue0a2" : ""}',
      \   },
      \   'component_function': {
      \     'ale_status':   s:SID . 'lightline_ale_status',
      \     'branch_name':  s:SID . 'lightline_branch_name',
      \     'filename':     s:SID . 'lightline_filename',
      \     'hunk_summary': s:SID . 'lightline_hunk_summary',
      \     'mode':         s:SID . 'lightline_mode',
      \   },
      \   'separator':    {'left': "\ue0b0", 'right': "\ue0b2"},
      \   'subseparator': {'left': "\ue0b1", 'right': "\ue0b3"},
      \ }

function! s:lightline_filename() abort
  let l:fname = expand('%:t')
  return  l:fname ==# 'ControlP' && has_key(g:lightline, 'ctrlp_item') ? g:lightline.ctrlp_item :
        \ l:fname !=# '' ? l:fname : '[No Name]'
endfunction

function! s:lightline_mode() abort
  let l:fname = expand('%:t')
  return  l:fname ==# 'ControlP' ? 'CtrlP' :
        \ lightline#mode()
endfunction

function! s:lightline_branch_name() abort
  if winwidth(0) >= 90 && exists('*gitbranch#name') && &filetype !=# 'help'
    let l:_ = gitbranch#name()
    return l:_ !=# '' ? "\ue0a0 " . l:_ : ''
  else
    return ''
  endif
endfunction

function! s:lightline_hunk_summary() abort
  if winwidth(0) >= 90 && get(g:, 'gitgutter_enabled')
    let l:hunks   = GitGutterGetHunkSummary()
    let l:symbols = [
          \   [g:gitgutter_sign_added,    l:hunks[0]],
          \   [g:gitgutter_sign_modified, l:hunks[1]],
          \   [g:gitgutter_sign_removed,  l:hunks[2]],
          \ ]
    return join(map(filter(l:symbols, 'v:val[1] > 0'), 'join(v:val)'))
  else
    return ''
  endif
endfunction

function! s:lightline_ale_status() abort
  if winwidth(0) >= 90
        \ && get(g:, 'ale_enabled', 0) == 1
        \ && exists('*ale#engine#IsCheckingBuffer')
        \ && getbufvar(bufnr(''), 'ale_linted', 0) > 0
        \ && ale#engine#IsCheckingBuffer(bufnr('')) == 0
    let l:counts = ale#statusline#Count(bufnr(''))
    let l:symbols = [
          \   ['🚫', l:counts.error],
          \   ['⚠️',  l:counts.warning],
          \   ['ℹ️',  l:counts.info],
          \ ]
    return join(map(filter(l:symbols, 'v:val[1] > 0'), 'join(v:val)'))
  else
    return ''
  endif
endfunction
" }}}

" vim-easy-align {{{
nmap <Leader>a <Plug>(EasyAlign)
xmap <Leader>a <Plug>(EasyAlign)
"}}}

" vim-dirvish {{{
nmap <Plug>(dirvish_up_) <Plug>(dirvish_up)
autocmd MyVimrc FileType dirvish nmap <buffer><silent> - <Plug>(dirvish_up)
" }}}

" clever-f.vim {{{
let g:clever_f_across_no_line = 1
let g:clever_f_smart_case     = 1
" }}}

" committia.vim {{{
let g:committia_hooks = {}
function! g:committia_hooks.edit_open(info) abort
  " enable spell checking
  setlocal spell

  " If no commit message, start with insert mode
  if a:info.vcs ==# 'git' && getline(1) ==# ''
    startinsert
  end
endfunction
" }}}

" caw.vim {{{
let g:caw_no_default_keymappings = 1
let g:caw_hatpos_skip_blank_line = 1

nmap <Leader>cc <Plug>(caw:hatpos:toggle:operator)
xmap <Leader>cc <Plug>(caw:hatpos:toggle)
nmap <Leader>ca <Plug>(caw:dollarpos:comment)
nmap <Leader>cw <Plug>(caw:wrap:toggle:operator)
xmap <Leader>cw <Plug>(caw:wrap:comment)
" }}}

" ale {{{
let g:ale_disable_lsp = 1
let g:ale_linters_explicit = 1
let g:ale_set_signs = 0

let g:ale_linters = {}
let g:ale_linters.vim = ['vint']

execute 'autocmd MyVimrc FileType ' . join(keys(g:ale_linters), ',') . ' call s:set_ale_keymappings()'
function! s:set_ale_keymappings() abort
  nmap <buffer> <Leader>gg <Plug>(ale_first)
  nmap <buffer> <Leader>gG <Plug>(ale_last)
  nmap <buffer> <Leader>gn <Plug>(ale_next_wrap)
  nmap <buffer> <Leader>gp <Plug>(ale_previous_wrap)
endfunction

autocmd MyVimrc User ALEJobStarted call lightline#update()
autocmd MyVimrc User ALELintPost call lightline#update()
autocmd MyVimrc User ALEFixPost call lightline#update()
" }}}

" LanguageClient-neovim {{{
let g:LanguageClient_serverCommands = {
      \   'haskell': ['hie-wrapper'],
      \   'rust': ['rustup', 'run', 'stable', 'rls'],
      \ }
let g:LanguageClient_diagnosticsDisplay = {
      \   1: {
      \     'name': 'Error',
      \     'texthl': 'SpellBad',
      \   },
      \   2: {
      \     'name': 'Warning',
      \     'texthl': 'SpellCap',
      \   },
      \   3: {
      \     'name': 'Information',
      \     'texthl': 'SpellCap',
      \   },
      \   4: {
      \     'name': 'Hint',
      \     'texthl': 'SpellCap',
      \   },
      \ }
let g:LanguageClient_diagnosticsList = 'Location'
let g:LanguageClient_diagnosticsSignsMax = 0
let g:LanguageClient_hoverPreview = 'Never'
let g:LanguageClient_selectionUI = 'quickfix'

autocmd MyVimrc FileType * call s:set_lc_keymappings()
function! s:set_lc_keymappings() abort
  if has_key(g:LanguageClient_serverCommands, expand('<amatch>'))
    nmap <buffer><silent> <Leader>gd :<C-u>call LanguageClient#textDocument_definition()<CR>
    nmap <buffer><silent> <Leader>gi :<C-u>call LanguageClient#textDocument_implementation()<CR>
    nmap <buffer><silent> <Leader>gt :<C-u>call LanguageClient#textDocument_typeDefinition()<CR>
    nmap <buffer><silent> <Leader>gr :<C-u>call LanguageClient#textDocument_references()<CR>
    nmap <buffer><silent> <Leader>t  :<C-u>call LanguageClient#textDocument_hover()<CR>

    command -buffer LCRename call LanguageClient#textDocument_rename()
  endif
endfunction
" }}}

" switch.vim {{{
nnoremap <silent> <Leader>sw :<C-u>Switch<CR>
" }}}

" indentLine {{{
let g:indentLine_fileType = ['yaml']

nnoremap <silent> <Leader>il :<C-u>IndentLinesToggle<CR>
" }}}

" vim-textmanip {{{
let g:textmanip_enable_mappings = 0
xmap <Leader>d <Plug>(textmanip-duplicate-down)
xmap <Leader>D <Plug>(textmanip-duplicate-up)
xmap <C-j>     <Plug>(textmanip-move-down)
xmap <C-k>     <Plug>(textmanip-move-up)
xmap <C-h>     <Plug>(textmanip-move-left)
xmap <C-l>     <Plug>(textmanip-move-right)

nmap <silent> <F10> <Plug>(textmanip-toggle-mode)
xmap <silent> <F10> <Plug>(textmanip-toggle-mode)
" }}}

" YouCompleteMe {{{
let g:ycm_complete_in_comments         = 1
let g:ycm_enable_diagnostic_signs      = 0
let g:ycm_extra_conf_vim_data          = ['&filetype']
let g:ycm_global_ycm_extra_conf        = '~/.vim/ycm_extra_conf.py'
let g:ycm_goto_buffer_command          = 'new-or-existing-tab'
let g:ycm_key_detailed_diagnostics     = ''
let g:ycm_key_list_previous_completion = []
let g:ycm_key_list_select_completion   = []
let g:ycm_key_list_stop_completion     = ['<C-y>']
let g:ycm_python_binary_path           = 'python'

autocmd MyVimrc FileType c,cpp call s:load_ycm()
function! s:load_ycm() abort
  silent! packadd YouCompleteMe
  nnoremap <buffer><silent> <Leader>f  :<C-u>YcmCompleter FixIt<CR>
  nnoremap <buffer><silent> <Leader>gD :<C-u>YcmCompleter GoToDefinition<CR>
  nnoremap <buffer><silent> <Leader>gd :<C-u>YcmCompleter GoToDeclaration<CR>
  nnoremap <buffer><silent> <Leader>t  :<C-u>YcmCompleter GetType<CR>
endfunction
" }}}

" UltiSnips {{{
let g:UltiSnipsExpandTrigger        = '<C-f>'
let g:UltiSnipsJumpBackwardTrigger  = '<C-b>'
let g:UltiSnipsJumpForwardTrigger   = '<C-f>'
" }}}

" vim-operator-user {{{
autocmd MyVimrc VimEnter * call s:init_user_defined_operators()
function! s:init_user_defined_operators() abort
  if !exists('*operator#user#define_ex_command') | return | endif

  call operator#user#define_ex_command('sort', 'sort')
  call operator#user#define_ex_command('sort-uniq', 'sort u')
endfunction

map <Leader>sl <Plug>(operator-sort)
map <Leader>su <Plug>(operator-sort-uniq)
" }}

" vim-operator-replace {{{
map <Leader>r  <Plug>(operator-replace)
" }}}

" vim-operator-surround {{{
map <Leader>sa <Plug>(operator-surround-append)
map <Leader>sd <Plug>(operator-surround-delete)
map <Leader>sr <Plug>(operator-surround-replace)
" }}}

" vim-clang-format {{{
let g:clang_format#auto_formatexpr = 1
let g:clang_format#style_options = {
      \   'AccessModifierOffset':             -2,
      \   'AlignConsecutiveAssignments':      'true',
      \   'AllowShortFunctionsOnASingleLine': 'Empty',
      \   'ColumnLimit':                      96,
      \   'Cpp11BracedListStyle':             'true',
      \   'DerivePointerAlignment':           'false',
      \   'SortIncludes':                     'false',
      \   'SpacesBeforeTrailingComments':     1,
      \   'Standard':                         'Cpp11',
      \ }
" }}}

" vim-markdown {{{
let g:vim_markdown_conceal                 = 0
let g:vim_markdown_folding_disabled        = 0
let g:vim_markdown_frontmatter             = 1
let g:vim_markdown_new_list_item_indent    = 0
let g:vim_markdown_no_default_key_mappings = 1
" }}}

" vim-markdown-composer {{{
let g:markdown_composer_autostart    = 0
let g:markdown_composer_open_browser = 1
" }}}
" }}}
