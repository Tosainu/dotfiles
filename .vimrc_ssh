augroup MyVimrc
  autocmd!
augroup END

set nocompatible
filetype off

" NeoBundle {{{
if has('vim_starting')
  set runtimepath+=~/.vim/bundle/neobundle.vim
  call neobundle#rc(expand('~/.vim/bundle/'))
endif

NeoBundleFetch 'Shougo/neobundle.vim'

NeoBundle 'Shougo/vimproc', {
      \   'build': {
      \     'unix': 'make -f make_unix.mak',
      \     'mac' : 'make -f make_mac.mak'
      \   }
      \ }
NeoBundle 'Shougo/unite.vim'
NeoBundle 'Shougo/vimfiler'
NeoBundle 'airblade/vim-gitgutter'
NeoBundle 'itchyny/lightline.vim'
NeoBundle 'scrooloose/syntastic'
NeoBundle 'sudo.vim'
NeoBundle 't9md/vim-textmanip'
NeoBundle 'tpope/vim-fugitive'
NeoBundle 'tpope/vim-surround'
NeoBundle 'tomtom/tcomment_vim'

" Completetion
NeoBundleLazy 'mattn/emmet-vim', {
      \   'autoload': {'filetypes': ['html', 'xhtml', 'css']}
      \ }

" Scheme
NeoBundle 'sk1418/last256', {
      \   'rev':  '48fb3d10c42c7a07cf6683c3e90fe9d9c8bd3131'
      \ }

" Languages
NeoBundleLazy 'vim-jp/cpp-vim', {
      \   'autoload': {'filetypes': 'cpp'}
      \ }
NeoBundleLazy 'JavaScript-syntax', {
      \   'autoload': {'filetypes': 'javascript'}
      \ }
NeoBundleLazy 'pangloss/vim-javascript', {
      \   'autoload': {'filetypes': 'javascript'}
      \ }
NeoBundleLazy 'vim-ruby/vim-ruby', {
      \   'autoload': {'filetypes': 'ruby'}
      \ }
NeoBundleLazy 'dag/vim2hs', {
      \   'autoload': {'filetypes': 'haskell'}
      \ }
NeoBundleLazy 'othree/html5.vim', {
      \   'autoload': {'filetypes': 'html'}
      \ }
NeoBundleLazy 'hail2u/vim-css3-syntax', {
      \   'autoload': {'filetypes': 'css'}
      \ }
NeoBundleLazy 'ap/vim-css-color', {
      \   'autoload': {'filetypes': ['css', 'html']}
      \ }
NeoBundleLazy 'tpope/vim-markdown', {
      \   'autoload': {'filetypes': 'markdown'}
      \ }
NeoBundleLazy 'sudar/vim-arduino-syntax', {
      \   'autoload': {'filename_patterns': '.*\.ino'}
      \ }

filetype plugin indent on
"}}}

" BasicSettings {{{
" Encoding
set encoding=utf-8
set fileencoding=utf=8
set fileformats=unix,dos,mac
set ambiwidth=double

" Display
set cursorline number ruler showmatch
set title

" Scheme
syntax enable
if $TERM == 'linux'
  colorscheme slate
  set background=dark
else
  set t_Co=256
  colorscheme last256
endif

" Search
set ignorecase smartcase incsearch hlsearch wrapscan

" Indent
set autoindent cindent
set expandtab smarttab
set tabstop=2 shiftwidth=2 backspace=2

" Commandline
set wildmenu wildmode=longest:full,full

" History
set history=20

" timeout
set timeoutlen=500
set updatetime=200

" show tabs
set list listchars=tab:Â»-,trail:-,eol:â†²,extends:Â»,precedes:Â«,nbsp:%

" filetypes
autocmd MyVimrc BufNewFile,BufRead *.{md,markdown} set filetype=markdown

" No Auto Comment.
autocmd MyVimrc FileType * setlocal formatoptions-=ro
"}}}

" keybind {{{
noremap <Esc>OA <NOP>
noremap <Esc>OB <Nop>
noremap <Esc>OC <Nop>
noremap <Esc>OD <Nop>
nnoremap <Esc><Esc> :nohlsearch<CR>
nnoremap :tn :tabnew<Space>
"}}}

" for C++ (http://rhysd.hatenablog.com/entry/2013/12/10/233201) {{{
autocmd MyVimrc FileType cpp setlocal path+=/usr/include/c++/*
autocmd MyVimrc FileType cpp inoremap <buffer><expr>; <SID>expand_namespace()

function! s:expand_namespace()
  let s = getline('.')[0:col('.')-1]
  if s =~# '\<b;$'
    return "\<BS>oost::"
  elseif s =~# '\<s;$'
    return "\<BS>td::"
  elseif s =~# '\<d;$'
    return "\<BS>etail::"
  else
    return ';'
  endif
endfunction
"}}}

" Unite.vim {{{
call unite#custom_default_action('file', 'tabopen')

" close <ESC> * 2
autocmd MyVimrc FileType unite nnoremap <silent> <buffer> <ESC><ESC> :q<CR>
autocmd MyVimrc FileType unite inoremap <silent> <buffer> <ESC><ESC> <ESC>:q<CR>

" http://deris.hatenablog.jp/entry/2013/05/02/192415
nnoremap [unite]    <Nop>
nmap     <Space>u [unite]
nnoremap <silent> [unite]f :<C-u>UniteWithCurrentDir -buffer-name=files file<CR>
nnoremap <silent> [unite]b :<C-u>Unite buffer<CR>
"}}}

" vim-gitgutter {{{
let g:gitgutter_sign_added = 'âœš'
let g:gitgutter_sign_modified = 'âžœ'
let g:gitgutter_sign_removed = 'âœ˜'
"}}}

" lightline.vim {{{
set laststatus=2
let g:lightline = {
      \   'colorscheme': 'wombat',
      \   'active': {
      \     'left': [
      \       ['mode'],
      \       ['readonly', 'filename', 'modified']
      \     ],
      \     'right': [
      \       ['lineinfo', 'syntastic'],
      \       ['percent'],
      \       ['fileformat', 'fileencoding', 'filetype'],
      \       ['gitgutter', 'fugitive']
      \     ]
      \   },
      \   'component_function': {
      \     'readonly': 'MyReadonly',
      \     'modified': 'MyModified',
      \     'fugitive': 'MyFugitive',
      \     'gitgutter': 'MyGitGutter',
      \     'syntastic': 'SyntasticStatuslineFlag'
      \   }
      \ }

function! MyModified()
  return &ft =~ 'help\|vimfiler' ? '' : &modified ? '+' : &modifiable ? '' : '-'
endfunction

function! MyReadonly()
  return &ft !~? 'help\|vimfiler' && &ro ? 'RO' : ''
endfunction

function! MyFugitive()
  return exists('*fugitive#head') ? fugitive#head() : ''
endfunction

function! MyGitGutter()
  if ! exists('*GitGutterGetHunkSummary')
        \ || ! get(g:, 'gitgutter_enabled', 0)
        \ || winwidth('.') <= 90
    return ''
  endif
  let symbols = [
        \ g:gitgutter_sign_added . ' ',
        \ g:gitgutter_sign_modified . ' ',
        \ g:gitgutter_sign_removed . ' '
        \ ]
  let hunks = GitGutterGetHunkSummary()
  let ret = []
  for i in [0, 1, 2]
    if hunks[i] > 0
      call add(ret, symbols[i] . hunks[i])
    endif
  endfor
  return join(ret, ' ')
endfunction
"}}}

" syntastic {{{
let g:syntastic_mode_map = {
      \   'mode': 'active',
      \   'passive_filetypes': ['tex']
      \ }
let g:syntastic_cpp_compiler_options = '-std=c++11'
"}}}

" vim-textmanip {{{
xmap <C-j> <Plug>(textmanip-move-down)
xmap <C-k> <Plug>(textmanip-move-up)
xmap <C-h> <Plug>(textmanip-move-left)
xmap <C-l> <Plug>(textmanip-move-right)
"}}}

" emmet-vim {{{
let g:user_emmet_leader_key = '<C-e>'
"}}}
